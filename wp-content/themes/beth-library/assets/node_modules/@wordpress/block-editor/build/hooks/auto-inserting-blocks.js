"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withAutoInsertingBlocks = void 0;
var _element = require("@wordpress/element");
var _i18n = require("@wordpress/i18n");
var _hooks = require("@wordpress/hooks");
var _components = require("@wordpress/components");
var _compose = require("@wordpress/compose");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _components2 = require("../components");
var _store = require("../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function AutoInsertingBlocksControl(props) {
  const {
    autoInsertedBlocksForCurrentBlock,
    groupedAutoInsertedBlocks
  } = (0, _data.useSelect)(select => {
    const {
      getBlockTypes
    } = select(_blocks.store);
    const _autoInsertedBlocksForCurrentBlock = getBlockTypes()?.filter(({
      autoInsert
    }) => autoInsert && props.blockName in autoInsert);

    // Group by block namespace (i.e. prefix before the slash).
    const _groupedAutoInsertedBlocks = _autoInsertedBlocksForCurrentBlock?.reduce((groups, block) => {
      const [namespace] = block.name.split('/');
      if (!groups[namespace]) {
        groups[namespace] = [];
      }
      groups[namespace].push(block);
      return groups;
    }, {});
    return {
      autoInsertedBlocksForCurrentBlock: _autoInsertedBlocksForCurrentBlock,
      groupedAutoInsertedBlocks: _groupedAutoInsertedBlocks
    };
  }, [props.blockName]);
  const {
    autoInsertedBlockClientIds,
    blockIndex,
    rootClientId,
    innerBlocksLength
  } = (0, _data.useSelect)(select => {
    const {
      getBlock,
      getBlockIndex,
      getBlockRootClientId
    } = select(_store.store);
    const _rootClientId = getBlockRootClientId(props.clientId);
    const _autoInsertedBlockClientIds = autoInsertedBlocksForCurrentBlock.reduce((clientIds, block) => {
      const relativePosition = block?.autoInsert?.[props.blockName];
      let candidates;
      switch (relativePosition) {
        case 'before':
        case 'after':
          // Any of the current block's siblings (with the right block type) qualifies
          // as an auto-inserted block (inserted `before` or `after` the current one),
          // as the block might've been auto-inserted and then moved around a bit by the user.
          candidates = getBlock(_rootClientId)?.innerBlocks;
          break;
        case 'first_child':
        case 'last_child':
          // Any of the current block's child blocks (with the right block type) qualifies
          // as an auto-inserted first or last child block, as the block might've been
          // auto-inserted and then moved around a bit by the user.
          candidates = getBlock(props.clientId).innerBlocks;
          break;
      }
      const autoInsertedBlock = candidates?.find(({
        name
      }) => name === block.name);
      if (autoInsertedBlock) {
        clientIds[block.name] = autoInsertedBlock.clientId;
      }

      // TOOD: If no auto-inserted block was found in any of its designated locations,
      // we want to check if it's present elsewhere in the block tree.
      // If it is, we'd consider it manually inserted and would want to remove the
      // corresponding toggle from the block inspector panel.

      return clientIds;
    }, {});
    return {
      blockIndex: getBlockIndex(props.clientId),
      innerBlocksLength: getBlock(props.clientId)?.innerBlocks?.length,
      rootClientId: _rootClientId,
      autoInsertedBlockClientIds: _autoInsertedBlockClientIds
    };
  }, [autoInsertedBlocksForCurrentBlock, props.blockName, props.clientId]);
  const {
    insertBlock,
    removeBlock
  } = (0, _data.useDispatch)(_store.store);
  if (!autoInsertedBlocksForCurrentBlock.length) {
    return null;
  }
  const insertBlockIntoDesignatedLocation = (block, relativePosition) => {
    switch (relativePosition) {
      case 'before':
      case 'after':
        insertBlock(block, relativePosition === 'after' ? blockIndex + 1 : blockIndex, rootClientId,
        // Insert as a child of the current block's parent
        false);
        break;
      case 'first_child':
      case 'last_child':
        insertBlock(block,
        // TODO: It'd be great if insertBlock() would accept negative indices for insertion.
        relativePosition === 'first_child' ? 0 : innerBlocksLength, props.clientId,
        // Insert as a child of the current block.
        false);
        break;
    }
  };
  return (0, _element.createElement)(_components2.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Plugins'),
    initialOpen: true
  }, Object.keys(groupedAutoInsertedBlocks).map(vendor => {
    return (0, _element.createElement)(_element.Fragment, {
      key: vendor
    }, (0, _element.createElement)("h3", null, vendor), groupedAutoInsertedBlocks[vendor].map(block => {
      // TODO: Display block icon.
      // <BlockIcon icon={ block.icon } />

      const checked = (block.name in autoInsertedBlockClientIds);
      return (0, _element.createElement)(_components.ToggleControl, {
        checked: checked,
        key: block.title,
        label: block.title,
        onChange: () => {
          if (!checked) {
            // Create and insert block.
            const relativePosition = block.autoInsert[props.blockName];
            insertBlockIntoDesignatedLocation((0, _blocks.createBlock)(block.name), relativePosition);
            return;
          }

          // Remove block.
          const clientId = autoInsertedBlockClientIds[block.name];
          removeBlock(clientId, false);
        }
      });
    }));
  })));
}
const withAutoInsertingBlocks = (0, _compose.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const blockEdit = (0, _element.createElement)(BlockEdit, {
      key: "edit",
      ...props
    });
    return (0, _element.createElement)(_element.Fragment, null, blockEdit, (0, _element.createElement)(AutoInsertingBlocksControl, {
      blockName: props.name,
      clientId: props.clientId
    }));
  };
}, 'withAutoInsertingBlocks');
exports.withAutoInsertingBlocks = withAutoInsertingBlocks;
if (window?.__experimentalAutoInsertingBlocks) {
  (0, _hooks.addFilter)('editor.BlockEdit', 'core/auto-inserting-blocks/with-inspector-control', withAutoInsertingBlocks);
}
//# sourceMappingURL=auto-inserting-blocks.js.map