{"version":3,"names":["_element","require","getFormatElement","range","editableContentElement","tagName","className","element","startContainer","nextElementSibling","nodeType","ELEMENT_NODE","parentElement","contains","selector","matches","createVirtualAnchorElement","contextElement","getBoundingClientRect","getAnchor","ownerDocument","defaultView","selection","getSelection","rangeCount","getRangeAt","formatElement","useAnchor","settings","anchor","setAnchor","useState","useLayoutEffect","callback","attach","addEventListener","detach","removeEventListener","activeElement"],"sources":["@wordpress/rich-text/src/component/use-anchor.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useState, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// If the caret is right before the element, select the next element.\n\telement = element.nextElementSibling || element;\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) return;\n\tif ( element === editableContentElement ) return;\n\tif ( ! editableContentElement.contains( element ) ) return;\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\tcontextElement: editableContentElement,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? range.getBoundingClientRect()\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) return;\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) return;\n\tif ( ! selection.rangeCount ) return;\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) return;\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) return formatElement;\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) return;\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tif ( editableContentElement === ownerDocument.activeElement ) {\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn detach;\n\t}, [ editableContentElement, tagName, className ] );\n\n\treturn anchor;\n}\n"],"mappings":"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"}