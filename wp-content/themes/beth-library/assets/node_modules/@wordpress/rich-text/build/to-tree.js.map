{"version":3,"names":["_getActiveFormats","require","_getFormatType","_specialCharacters","restoreOnAttributes","attributes","isEditableTree","newAttributes","key","newKey","startsWith","slice","length","fromFormat","type","tagName","unregisteredAttributes","object","boundaryClass","formatType","getFormatType","elementAttributes","name","className","class","contentEditable","contenteditable","isEqualUntil","a","b","index","toTree","value","multilineTag","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","placeholder","formats","replacements","text","start","end","formatsLength","tree","multilineFormat","activeFormats","getActiveFormats","deepestActiveFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","i","character","charAt","shouldInsertPadding","LINE_SEPARATOR","characterFormats","reduce","accumulator","format","push","pointer","node","ZWNBSP","forEach","formatIndex","parent","newNode","OBJECT_REPLACEMENT_CHARACTER","replacement","innerHTML","html","decodeURIComponent","undefined","style"],"sources":["@wordpress/rich-text/src/to-tree.js"],"sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\t// When a format is declared as non editable, make it non editable in the\n\t// editor.\n\tif ( isEditableTree && formatType.contentEditable === false ) {\n\t\telementAttributes.contenteditable = 'false';\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\tlastCharacter === LINE_SEPARATOR ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = (\n\t\t\t\t\treplacements[ i ] || []\n\t\t\t\t).reduce(\n\t\t\t\t\t( accumulator, format ) => {\n\t\t\t\t\t\taccumulator.push( format, multilineFormat );\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t},\n\t\t\t\t\t[ multilineFormat ]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [\n\t\t\t\t\t...lastSeparatorFormats,\n\t\t\t\t\t...( characterFormats || [] ),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( shouldInsertPadding && character === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tappend( getParent( node ), ZWNBSP );\n\t\t}\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t) &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree &&\n\t\t\t\t\tcharacter !== LINE_SEPARATOR &&\n\t\t\t\t\tformat === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) continue;\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\tboundaryClass: start === i && end === i + 1,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"],"mappings":"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"}