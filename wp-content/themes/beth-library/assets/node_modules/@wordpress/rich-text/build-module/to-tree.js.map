{"version":3,"names":["getActiveFormats","getFormatType","LINE_SEPARATOR","OBJECT_REPLACEMENT_CHARACTER","ZWNBSP","restoreOnAttributes","attributes","isEditableTree","newAttributes","key","newKey","startsWith","slice","length","fromFormat","type","tagName","unregisteredAttributes","object","boundaryClass","formatType","elementAttributes","name","className","class","contentEditable","contenteditable","isEqualUntil","a","b","index","toTree","value","multilineTag","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","placeholder","formats","replacements","text","start","end","formatsLength","tree","multilineFormat","activeFormats","deepestActiveFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","i","character","charAt","shouldInsertPadding","characterFormats","reduce","accumulator","format","push","pointer","node","forEach","formatIndex","parent","newNode","replacement","innerHTML","html","decodeURIComponent","undefined","style"],"sources":["@wordpress/rich-text/src/to-tree.js"],"sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\t// When a format is declared as non editable, make it non editable in the\n\t// editor.\n\tif ( isEditableTree && formatType.contentEditable === false ) {\n\t\telementAttributes.contenteditable = 'false';\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\tlastCharacter === LINE_SEPARATOR ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = (\n\t\t\t\t\treplacements[ i ] || []\n\t\t\t\t).reduce(\n\t\t\t\t\t( accumulator, format ) => {\n\t\t\t\t\t\taccumulator.push( format, multilineFormat );\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t},\n\t\t\t\t\t[ multilineFormat ]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [\n\t\t\t\t\t...lastSeparatorFormats,\n\t\t\t\t\t...( characterFormats || [] ),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( shouldInsertPadding && character === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tappend( getParent( node ), ZWNBSP );\n\t\t}\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t) &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree &&\n\t\t\t\t\tcharacter !== LINE_SEPARATOR &&\n\t\t\t\t\tformat === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) continue;\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\tboundaryClass: start === i && end === i + 1,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"],"mappings":"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"}