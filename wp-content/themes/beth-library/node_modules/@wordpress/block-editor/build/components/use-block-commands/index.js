"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTransformCommands = exports.useBlockCommands = void 0;
var _i18n = require("@wordpress/i18n");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _commands = require("@wordpress/commands");
var _icons = require("@wordpress/icons");
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const useTransformCommands = () => {
  const {
    clientIds
  } = (0, _data.useSelect)(select => {
    const {
      getSelectedBlockClientIds
    } = select(_store.store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    return {
      clientIds: selectedBlockClientIds
    };
  }, []);
  const blocks = (0, _data.useSelect)(select => select(_store.store).getBlocksByClientId(clientIds), [clientIds]);
  const {
    replaceBlocks,
    multiSelect
  } = (0, _data.useDispatch)(_store.store);
  const {
    possibleBlockTransformations,
    canRemove
  } = (0, _data.useSelect)(select => {
    const {
      getBlockRootClientId,
      getBlockTransformItems,
      canRemoveBlocks
    } = select(_store.store);
    const rootClientId = getBlockRootClientId(Array.isArray(clientIds) ? clientIds[0] : clientIds);
    return {
      possibleBlockTransformations: getBlockTransformItems(blocks, rootClientId),
      canRemove: canRemoveBlocks(clientIds, rootClientId)
    };
  }, [clientIds, blocks]);
  const isTemplate = blocks.length === 1 && (0, _blocks.isTemplatePart)(blocks[0]);
  function selectForMultipleBlocks(insertedBlocks) {
    if (insertedBlocks.length > 1) {
      multiSelect(insertedBlocks[0].clientId, insertedBlocks[insertedBlocks.length - 1].clientId);
    }
  }

  // Simple block tranformation based on the `Block Transforms` API.
  function onBlockTransform(name) {
    const newBlocks = (0, _blocks.switchToBlockType)(blocks, name);
    replaceBlocks(clientIds, newBlocks);
    selectForMultipleBlocks(newBlocks);
  }

  /**
   * The `isTemplate` check is a stopgap solution here.
   * Ideally, the Transforms API should handle this
   * by allowing to exclude blocks from wildcard transformations.
   */
  const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
  if (!clientIds || clientIds.length < 1 || !hasPossibleBlockTransformations) {
    return {
      isLoading: false,
      commands: []
    };
  }
  const commands = possibleBlockTransformations.map(transformation => {
    const {
      name,
      title,
      icon
    } = transformation;
    return {
      name: 'core/block-editor/transform-to-' + name.replace('/', '-'),
      // translators: %s: block title/name.
      label: (0, _i18n.sprintf)((0, _i18n.__)('Transform to %s'), title),
      icon: icon.src,
      callback: ({
        close
      }) => {
        onBlockTransform(name);
        close();
      }
    };
  });
  return {
    isLoading: false,
    commands
  };
};
exports.useTransformCommands = useTransformCommands;
const useActionsCommands = () => {
  const {
    clientIds
  } = (0, _data.useSelect)(select => {
    const {
      getSelectedBlockClientIds
    } = select(_store.store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    return {
      clientIds: selectedBlockClientIds
    };
  }, []);
  const {
    canInsertBlockType,
    getBlockRootClientId,
    getBlocksByClientId,
    canMoveBlocks,
    canRemoveBlocks
  } = (0, _data.useSelect)(_store.store);
  const {
    getDefaultBlockName,
    getGroupingBlockName
  } = (0, _data.useSelect)(_blocks.store);
  const blocks = getBlocksByClientId(clientIds);
  const rootClientId = getBlockRootClientId(clientIds[0]);
  const canDuplicate = blocks.every(block => {
    return !!block && (0, _blocks.hasBlockSupport)(block.name, 'multiple', true) && canInsertBlockType(block.name, rootClientId);
  });
  const canInsertDefaultBlock = canInsertBlockType(getDefaultBlockName(), rootClientId);
  const canMove = canMoveBlocks(clientIds, rootClientId);
  const canRemove = canRemoveBlocks(clientIds, rootClientId);
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    setBlockMovingClientId,
    setNavigationMode,
    selectBlock
  } = (0, _data.useDispatch)(_store.store);
  const onDuplicate = () => {
    if (!canDuplicate) {
      return;
    }
    return duplicateBlocks(clientIds, true);
  };
  const onRemove = () => {
    if (!canRemove) {
      return;
    }
    return removeBlocks(clientIds, true);
  };
  const onAddBefore = () => {
    if (!canInsertDefaultBlock) {
      return;
    }
    const clientId = Array.isArray(clientIds) ? clientIds[0] : clientId;
    insertBeforeBlock(clientId);
  };
  const onAddAfter = () => {
    if (!canInsertDefaultBlock) {
      return;
    }
    const clientId = Array.isArray(clientIds) ? clientIds[clientIds.length - 1] : clientId;
    insertAfterBlock(clientId);
  };
  const onMoveTo = () => {
    if (!canMove) {
      return;
    }
    setNavigationMode(true);
    selectBlock(clientIds[0]);
    setBlockMovingClientId(clientIds[0]);
  };
  const onGroup = () => {
    if (!blocks.length) {
      return;
    }
    const groupingBlockName = getGroupingBlockName();

    // Activate the `transform` on `core/group` which does the conversion.
    const newBlocks = (0, _blocks.switchToBlockType)(blocks, groupingBlockName);
    if (!newBlocks) {
      return;
    }
    replaceBlocks(clientIds, newBlocks);
  };
  const onUngroup = () => {
    if (!blocks.length) {
      return;
    }
    const innerBlocks = blocks[0].innerBlocks;
    if (!innerBlocks.length) {
      return;
    }
    replaceBlocks(clientIds, innerBlocks);
  };
  if (!clientIds || clientIds.length < 1) {
    return {
      isLoading: false,
      commands: []
    };
  }
  const icons = {
    ungroup: _icons.ungroup,
    group: _icons.group,
    move: _icons.moveTo,
    add: _icons.create,
    remove: _icons.edit,
    duplicate: _icons.copy
  };
  const commands = [onUngroup, onGroup, onMoveTo, onAddAfter, onAddBefore, onRemove, onDuplicate].map(callback => {
    const action = callback.name.replace('on', '').replace(/([a-z])([A-Z])/g, '$1 $2');
    return {
      name: 'core/block-editor/action-' + callback.name,
      // translators: %s: type of the command.
      label: action,
      icon: icons[callback.name.replace('on', '').match(/[A-Z]{1}[a-z]*/).toString().toLowerCase()],
      callback: ({
        close
      }) => {
        callback();
        close();
      }
    };
  });
  return {
    isLoading: false,
    commands
  };
};
const useBlockCommands = () => {
  (0, _commands.useCommandLoader)({
    name: 'core/block-editor/blockTransforms',
    hook: useTransformCommands
  });
  (0, _commands.useCommandLoader)({
    name: 'core/block-editor/blockActions',
    hook: useActionsCommands
  });
};
exports.useBlockCommands = useBlockCommands;
//# sourceMappingURL=index.js.map